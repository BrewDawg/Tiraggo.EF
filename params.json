{"name":"Tiraggo.ef","tagline":"The Tiraggo Dynamic Query API for the Entity Framework","body":"##The Tiraggo Dynamic Query API for the Entity Framework##\r\n\r\nCopyright © Mike Griffin 2013 (http://www.tiraggo.com)\r\n\r\nLicense: [MIT](https://raw.github.com/BrewDawg/Tiraggo.EF/master/License.txt)\r\n\r\n[NuGet Package](https://www.nuget.org/profiles/Mike.Griffin/) install from within Visual Studio using the NuGet Package Manager.\r\n\r\n##Tired of LINQ and Lamba?##\r\nTap into your T-SQL knowledge and write queries that actually make sense. Have you ever stumbled upon LINQ queries that are so unintelligible and complex you needed to crawl under your desk and have a good cry? Have you ever taken a look at the horrid SQL generated by LINQ? And what's with this not being able to select certain columns? This is 2013 folks. \r\n\r\nNow you can have the best of both worlds; the Tiraggo Dynamic Query API (based on EntitySpaces) and your Entity Framework entities.\r\n\r\n#The Syntax##\r\nWhat developer doesn't have a good grasp of the T-SQL syntax? The goal behind the Tiraggo API is to mimic the T-SQL syntax. This has two advantages, your learning curve is minimal and the SQL spit out is very clean.\r\n\r\n##A Simple Sample with an InnerJoin##\r\nThe sample below demonstrates a self join on the Employees table which is looking for all employees with an 'a' in their last name who have people reporting to them. Kind of silly but it shows off the syntax.\r\n\r\nFull Intellisense Support\r\n```csharp\r\nEmployeeQuery q = new EmployeeQuery(\"e\");\r\nEmployeeQuery q1 = new EmployeeQuery(\"e1\");\r\n\r\nq.Select(q.EmployeeID, q.LastName)  // To bind to combobox\r\n\t.Where(q.LastName.Like(\"%a%\"))\r\n\t.InnerJoin(q1).On(q.EmployeeID == q1.ReportsTo)\r\n\t.OrderBy(q.LastName.Descending);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Employee> employees = q.ToList<Employee>(context);\r\n}\r\n```\r\n\r\nYep, you can actually select only the columns you desire and the SQL is extremely lean. Tiraggo.EF only requires a single .NET assembly and no config settings.\r\n\r\nNOTE: <b>InnerJoin</b> is used above, also supported are <b>RightJoin</b>, <b>LeftJoin</b>, <b>CrossJoin</b>, and <b>FullJoin</b>.\r\n\r\nResults from the Query Above\r\n```sql\r\nSELECT\r\n   e.[EmployeeID],\r\n   e.[LastName]  \r\nFROM\r\n   [Employees] e \r\nINNER JOIN [Employees] e1 \r\n   ON e.[EmployeeID] = e1.[ReportsTo] \r\nWHERE\r\n   e.[LastName] LIKE @LastName1 \r\nORDER BY\r\n   e.[LastName] DESC\r\n```\r\n\r\nCompare that SQL to the SQL generated by a Entity Framework query which does the same thing and you'll be shocked.\r\n\r\nThere are more ways that ToList() to fetch data.\r\n\r\n- ToList<>()\r\n- ToArray<>()\r\n- ToDictionary<>() - Primary key is the \"Key\" value\r\n- ToAnonymousType() \r\n\r\n```csharp\r\nErrorLogQuery q = new ErrorLogQuery();\r\nq.Select(q.ErrorLogId, q.Method, q.Message);\r\nq.OrderBy(q.DateOccurred.Descending);\r\n\r\nusing (MyEntities context = new MyEntities ())\r\n{\r\n  // List\r\n  List<ErrorLog> list = q.ToList<ErrorLog>(context);\r\n\r\n  // Array\r\n  ErrorLog[] array = q.ToArray<ErrorLog>(context);\r\n\r\n  // Dictionary where \"Key\" is the Primary Key\r\n  Dictionary<Guid, ErrorLog> dict = q.ToDictionary<Guid, ErrorLog>(context);\r\n\r\n  // Anonymous - useful when bringing back extra columns in a join \r\n  var anonymous = q.ToAnonymousType(context)\r\n      .Select(p => new { p.ErrorLogId, p.Message }).ToList();\r\n}\r\n```\r\n\r\n#How does it work#\r\nWhen you install the Tiraggo.EF NuGet package it will install two T4 templates into your Visual Studio solution. Both will run successfully but only one will generate code depending on whether you have V2 or V3 EDMX files. The templates will be installed in your Models folder. \r\n\r\n<B>Provide the name of your EDMX File</B>\r\n\r\nYou will have to edit the two T4 templates and add the name of your EDMX file in both templates. \r\n\r\nLike so:\r\n```csharp\r\n// ******************************************\r\n// *** CHANGE THIS TO YOUR EDMX FILE NAME ***\r\n// ******************************************\r\nstring edxmFileName = @\"MyModel.edmx\";\r\n```\r\n\r\nOnce you see which template generates your code you can remove the other if you like.\r\n\r\nYou can tell what version your EDMX files are by looking at them in XML format, the version is right at the top:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<edmx:Edmx Version=\"3.0\" xmlns:edmx=\"http://schemas...\">\r\n```\r\n\r\nNotice below that the \"TiraggoEF_v3.tt\" template generated the Query class in my solution. This is because I am in VS2012 and generating V3 EDMX files. \r\n\r\n![ScreenShot](http://www.brewdawg.com/TiraggoEF_Project.png)\r\n\r\n<b>Tiraggo.EF Assemblies</b>\r\n\r\nA reference to \"Tiraggo.DynamicQuery.EF.dll\" will be added to your solution as a reference. This is the only assembly your application will to use at runtime to use your Tiraggo.EF query classes.\r\n\r\nThere is also a \"TiraggoEdmx.EF.dll\" assembly added to a folder in your project named \"TiraggoEdmx\". This assembly is used by the Tiraggo.EF T4 templates and you do not need to ship this assembly. This assembly provides the low level metadata that Microsoft EDMX API refuses to serve up. For example, the mappings between your conceptual model and the storage model including primitive information such as low level SQL Server columns types like \"nvarchar\". I am making some enhancements in the assembly and will release \"TiraggoEdmx\" as a separate NuGet package on it's own. TiraggoEdmx is a far superior way to write T4 templates against EDMX files, everything is fully exposed.\r\n\r\nYou can see a sample of it [HERE](https://github.com/BrewDawg/Tiraggo.EF/blob/master/TiraggoEdmx/TiraggoEntityInfo_v3.cs). Again, I am making big improvements to this and will release in about two weeks so wait for that release if you're interested.\r\n\r\n#Back to the Syntax#\r\n\r\n##Supported Operators##\r\nUse the native language syntax, it works as you expect it would.\r\n- +\r\n- -\r\n- *\r\n- /\r\n- %\r\n- >\r\n- <\r\n- <=\r\n- >=\r\n- ==\r\n- != \r\n- && = SQL 'AND' in VB use \"And\"\r\n- || = SQL 'OR' in VB use \"Or\"\r\n\r\n##Sub Operators###\r\n\r\n- ToUpper - Convert to lower case\r\n- ToLower - Left trim any leading spaces\r\n- LTrim - Left trim any trailing spaces\r\n- RTrim - - Right trim any trailing spaces\r\n- Trim - Trim both leading and trailing spaces\r\n- SubString - Return a sub-string \r\n- Coalesce - Return the first non null evaluating expression\r\n- Date - Returns only the date of a datetime type\r\n- DatePart - Returns the value of part of a datetime value.\r\n- Length - Return the length\r\n- Round - Rounds the numeric-expression to the desired places after the decimal point.\r\n- Avg - Average\r\n- Count - Count operator\r\n- Max - Maximum Value\r\n- Min - Minimum Value\r\n- StdDev - Standard Deviation\r\n- Var - Variance\r\n- Sum - Summation\r\n- Cast - SQL Cast\r\n\r\n##More Samples##\r\n\r\n###Select Top###\r\n```csharp\r\nEmployeesQuery q = new EmployeesQuery();\r\nq.tg.Top = 1; // TOP\r\nq.Where(q.EmployeeID == 1 && (q.LastName != \"googy\"));\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Employee> employees = q.ToList<Employee>(context);\r\n}\r\n```\r\n\r\nResult:\r\n```sql\r\nSELECT  TOP 1 * \r\nFROM [Employees] \r\nWHERE ([EmployeeID] = @EmployeeID1 AND [LastName] <> @LastName2)\r\n```\r\n\r\n###SelectAllExcept###\r\nSelectAllExcept() is not really a SubQuery, just a convenient enhancement that allows you to select all except one or more listed columns.\r\n\r\n```csharp\r\nEmployeeQuery q = new EmployeeQuery();\r\nq.SelectAllExcept(q.Photo);  // We don't want to bring back the huge photo\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Employee> employees = q.ToList<Employee>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT [EmployeeID],[LastName],[FirstName],[Supervisor],[Age]  -- not [Photo]\r\nFROM [dbo].[Employee]\r\n```\r\n\r\n###Getting the Count###\r\n```csharp\r\nErrorLogQuery q = new ErrorLogQuery();\r\nq.Where(q.Message.Like(\"%a\"));\r\nq.tg.CountAll = true;\r\n\r\nusing (MyEntities context = new MyEntities ())\r\n{\r\n\tlong l = q.ExecuteScalar<long>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT COUNT(*) AS 'Count' \r\nFROM [dbo].[ErrorLog] \r\nWHERE [Message] LIKE @Message1\r\n```\r\n\r\n###Paging###\r\n\r\n<b>Using PageSize and PageNumber</b>. \r\n\r\nThis is the traditional way of paging and works on all versions of SQL Server. You always need an OrderBy when sorting.\r\n\r\n```csharp\r\nErrorLogQuery q = new ErrorLogQuery();\r\nq.Select(q.ErrorLogId, q.Method, q.Message);\r\nq.OrderBy(q.DateOccurred.Descending);\r\nq.tg.PageNumber = 2;\r\nq.tg.PageSize = 20;\r\n\r\nusing (MyEntities context = new MyEntities())\r\n{\r\n\tIList<ErrorLog> errors = q.ToList<ErrorLog>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nWITH [withStatement] AS \r\n(\r\n\tSELECT [errorlogid], \r\n\t\t[method], \r\n\t\t[message], \r\n\t\tRow_number() OVER\r\n\t\t( \r\n\t\t\tORDER BY [dateoccurred] DESC\r\n\t\t) AS ESRN \r\n\tFROM [dbo].[errorlog]\r\n) \r\nSELECT * \r\nFROM [withStatement] \r\nWHERE esrn BETWEEN 21 AND 40 \r\nORDER BY esrn ASC \r\n```\r\n\r\n<b>Using Skip and Take for paging</b>. \r\n\r\nSkip and Take Require Microsoft SQL 2012 at a minimum and is a much nicer syntax.\r\n\r\n```csharp\r\nErrorLogQuery q = new ErrorLogQuery();\r\nq.Select(q.ErrorLogId, q.Method, q.Message);\r\nq.OrderBy(q.DateOccurred.Descending);\r\nq.Skip(40).Take(20);\r\n\r\nusing (MyEntities context = new MyEntities())\r\n{\r\n\tIList<ErrorLog> errors = q.ToList<ErrorLog>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT [ErrorLogId],[Method],[Message]  \r\nFROM [dbo].[ErrorLog] \r\nORDER BY [DateOccurred] DESC \r\nOFFSET 40 ROWS \r\nFETCH NEXT 20 ROWS ONLY\r\n```\r\n\r\n###With NoLock###\r\n\r\n```csharp\r\nOrderQuery oq = new OrderQuery(\"o\");\r\nOrderItemQuery oiq = new OrderItemQuery(\"oi\");\r\n\r\noq.Select(oq.CustID, oq.OrderDate, \"<sub.OrderTotal>\");\r\noq.From\r\n    (\r\n        oiq.Select(oiq.OrderID,\r\n            (oiq.UnitPrice * oiq.Quantity).Sum().As(\"OrderTotal\"))\r\n            .GroupBy(oiq.OrderID)\r\n    ).As(\"sub\");\r\noq.InnerJoin(oq).On(oq.OrderID == oiq.OrderID);\r\noq.tg.WithNoLock = true;\r\n\r\nusing (MyEntities context = new MyEntities())\r\n{\r\n\tIList<Order> orders = q.ToList<Order>(context);\r\n}\r\n```\r\n\r\nNotice that even though many query objects are being used you only need to set WithNoLock to true for the parent or main query object. The SQL generated is as follows:\r\n\r\nResults:\r\n```sql\r\nSELECT o.[CustID],o.[OrderDate],sub.OrderTotal  \r\nFROM \r\n(\r\n   SELECT oi.[OrderID],SUM((oi.[UnitPrice]*oi.[Quantity])) AS 'OrderTotal'  \r\n   FROM [OrderItem] oi WITH (NOLOCK) \r\n   GROUP BY oi.[OrderID]\r\n) AS sub \r\nINNER JOIN [Order] o WITH (NOLOCK) \r\nON o.[OrderID] = sub.[OrderID] \r\n```\r\n\r\n###Full Expressions in OrderBy and GroupBy###\r\n\r\nThis query doesn’t really make sense, but we wanted to show you what will be possible in the next release.\r\n\r\n```csharp\r\nEmployeesQuery q = new EmployeesQuery(); \r\nq.Select(q.LastName.Substring(2, 4).ToLower()); \r\nq.OrderBy(q.LastName.Substring(2, 4).ToLower().Descending); \r\nq.GroupBy(q.LastName.Substring(2, 4).ToLower());\r\n\r\nusing (MyEntities context = new MyEntities())\r\n{\r\n\tIList<ErrorLog> errors = q.ToList<ErrorLog>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT SUBSTRING(LOWER([LastName]),2,4) AS 'LastName' \r\nFROM [Employees] \r\nGROUP BY SUBSTRING(LOWER([LastName]),2,4) \r\nORDER BY SUBSTRING(LOWER([LastName]),2,4) DESC\r\n```\r\n\r\n###Select SubQuery###\r\n\r\nA SubQuery in a Select clause must return a single value.\r\n\r\n```csharp\r\nOrderQuery orders = new OrderQuery(\"o\");\r\nOrderItemQuery details = new OrderItemQuery(\"oi\");\r\n\r\norders.Select\r\n(\r\n    orders.OrderID,\r\n    orders.OrderDate,\r\n    details.Select\r\n\t(\r\n        details.UnitPrice.Max()\r\n\t)\r\n    .Where(orders.OrderID == details.OrderID).As(\"MaxUnitPrice\")\r\n);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Order> theOrders = orders.ToList<Order>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT o.[OrderID],o.[OrderDate], \r\n(\r\n\tSELECT MAX(oi.[UnitPrice]) AS 'UnitPrice'  \r\n\tFROM [dbo].[OrderItem] oi \r\n\tWHERE o.[OrderID] = oi.[OrderID]\r\n) AS MaxUnitPrice  \r\nFROM [dbo].[Order] o\r\n```\r\n\r\nThis is the same as the query above, but returns all columns in the Order table, instead of just OrderID and OrderDate. Notice that the Select clause contains orders, not orders.*. The SQL produced will use the supplied alias o.*.\r\n\r\n```csharp\r\nOrderQuery orders = new OrderQuery(\"o\");\r\nOrderItemQuery details = new OrderItemQuery(\"oi\");\r\n\r\norders.Select\r\n(\r\n    orders, // this means orders.*\r\n    details.Select\r\n\t(\r\n        details.UnitPrice.Max()\r\n\t)\r\n    .Where(orders.OrderID == details.OrderID).As(\"MaxUnitPrice\")\r\n);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Order> theOrders = orders.ToList<Order>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT o.* \r\n(\r\n\tSELECT MAX(oi.[UnitPrice]) AS 'UnitPrice'  \r\n\tFROM [dbo].[OrderItem] oi \r\n\tWHERE o.[OrderID] = oi.[OrderID]\r\n) AS MaxUnitPrice  \r\nFROM [ForeignKeyTest].[dbo].[Order] o\r\n```\r\n\r\n###From SubQuery###\r\n\r\nAn aggregate requires a GROUP BY for each column in the SELECT that is not an aggregate. Sometimes you wish to include columns in your result set that you do not wish to group by. One way to accomplish this is by using a SubQuery in the From clause that contains the aggregate the way you want it grouped. The outer query contains the results of the aggregate, plus any additional columns.\r\n\r\nIf you use a SubQuery in a From clause, you must give the From clause its own alias (shown below as \"sub\"). In the outer query, to refer to an aliased element in the From SubQuery, use the inline raw SQL technique to qualify the aggregate's alias with the From clause alias, i.e., \"<sub.OrderTotal>\".\r\n\r\n```csharp\r\nOrderQuery oq = new OrderQuery(\"o\");\r\nOrderItemQuery oiq = new OrderItemQuery(\"oi\");\r\n\r\noq.Select(oq.CustID, oq.OrderDate, \"<sub.OrderTotal>\");\r\noq.From\r\n(\r\n\toiq.Select\r\n\t(\r\n\t\toiq.OrderID,\r\n\t\t(oiq.UnitPrice * oiq.Quantity).Sum().As(\"OrderTotal\")\r\n\t)\r\n\t.GroupBy(oiq.OrderID)\r\n).As(\"sub\");\r\noq.InnerJoin(oq).On(oq.OrderID == oiq.OrderID);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Order> oq = orders.ToList<Order>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT o.[CustID],o.[OrderDate],sub.OrderTotal  \r\nFROM \r\n(\r\n\tSELECT oi.[OrderID],\r\n\tSUM((oi.[UnitPrice]*oi.[Quantity])) AS 'OrderTotal'  \r\n\tFROM [dbo].[OrderItem] oi \r\n\tGROUP BY oi.[OrderID]\r\n) AS sub \r\nINNER JOIN [dbo].[Order] o ON o.[OrderID] = sub.[OrderID]\r\n```\r\n\r\n###Where SubQuery###\r\n\r\nIn and NotIn are two of the most common operators used in a Where SubQuery. The following produces a result set containing Territories that an Employee is not associated with.\r\n\r\n```csharp\r\n// SubQuery of Territories that Employee 1 is assigned to.\r\nEmployeeTerritoryQuery etq = new EmployeeTerritoryQuery(\"et\");\r\netq.Select(etq.TerrID);\r\netq.Where(etq.EmpID == 1);\r\n\r\n// Territories that Employee 1 is not assigned to.\r\nTerritoryQuery tq = new TerritoryQuery(\"t\");\r\ntq.Select(tq.Description);\r\ntq.Where(tq.TerritoryID.NotIn(etq));\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Territory> territories = tq.ToList<Territory>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT t.[Description]  \r\nFROM [dbo].[Territory] t \r\nWHERE t.[TerritoryID] NOT IN \r\n(\r\n    SELECT et.[TerrID]  \r\n    FROM .[dbo].[EmployeeTerritory] et \r\n    WHERE et.[EmpID] = @EmpID1\r\n) \r\n```\r\n\r\nExists evaluates to true, if the SubQuery returns a result set.\r\n\r\n```csharp\r\n// SubQuery of Employees with a null Supervisor column.\r\nEmployeeQuery sq = new EmployeeQuery(\"s\");\r\nsq.tg.Distinct = true;\r\nsq.Select(sq.EmployeeID);\r\nsq.Where(sq.Supervisor.IsNull());\r\n\r\n// If even one employee has a null supervisor,\r\n// i.e., the above query has a result set,\r\n// then run a list of all employees.\r\nEmployeeQuery eq = new EmployeeQuery(\"e\");\r\neq.Select(eq.EmployeeID, eq.Supervisor);\r\neq.Where(eq.Exists(sq));\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Employee> employees = eq.ToList<Employee>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT e.[EmployeeID],e.[Supervisor]  \r\nFROM [dbo].[Employee] e \r\nWHERE EXISTS \r\n(\r\n    SELECT DISTINCT s.[EmployeeID]  \r\n    FROM [dbo].[Employee] s \r\n    WHERE s.[Supervisor] IS NULL\r\n)\r\n```\r\n\r\n###Join(query).On(SubQuery)###\r\n\r\nSubQueries cannot be used directly within a Join(SubQuery) clause, but they can be used within a Join(query).On(SubQuery) clause.\r\n\r\n```csharp\r\n// Query for the Join\r\nOrderItemQuery oiq = new OrderItemQuery(\"oi\");\r\n\r\n// SubQuery of OrderItems with a discount\r\nOrderItemQuery oisq = new OrderItemQuery(\"ois\");\r\noisq.tg.Distinct = true;\r\noisq.Select(oisq.Discount);\r\noisq.Where(oisq.Discount > 0);\r\n\r\n// Orders with discounted items\r\nOrderQuery oq = new OrderQuery(\"o\");\r\noq.Select(oq.OrderID, oiq.Discount);\r\noq.InnerJoin(oiq).On(oq.OrderID == oiq.OrderID && oiq.Discount.In(oisq));\r\n\t\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Order> orders = oq.ToList<Order>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT o.[OrderID],oi.[Discount]  \r\nFROM [dbo].[Order] o \r\nINNER JOIN [dbo].[OrderItem] oi \r\nON (o.[OrderID] = oi.[OrderID] AND oi.[Discount] IN  \r\n(\r\n    SELECT  DISTINCT ois.[Discount]  \r\n    FROM [dbo].[OrderItem] ois \r\n    WHERE ois.[Discount] > @Discount1)\r\n)\r\n```\r\n\r\n###Correlated SubQuery###\r\n\r\nA correlated SubQuery is where the inner query relies on an element of the outer query. The inner select cannot run on its own. Below, the inner pq query uses the outer query's oiq.ProductID in the Where() clause.\r\n\r\n```csharp\r\nOrderItemQuery oiq = new OrderItemQuery(\"oi\");\r\nProductQuery pq = new ProductQuery(\"p\");\r\n\r\noiq.Select(\r\n    oiq.OrderID,\r\n    (oiq.Quantity * oiq.UnitPrice).Sum().As(\"Total\")\r\n);\r\noiq.Where(oiq.ProductID\r\n    .In(\r\n        pq.Select(pq.ProductID)\r\n        .Where(oiq.ProductID == pq.ProductID)\r\n    )\r\n);\r\noiq.GroupBy(oiq.OrderID);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Order> orders = oiq.ToList<Order>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT oi.[OrderID],SUM((oi.[Quantity]*oi.[UnitPrice])) AS 'Total'  \r\nFROM [dbo].[OrderItem] oi \r\nWHERE oi.[ProductID] IN \r\n(\r\n    SELECT p.[ProductID]  \r\n    FROM [dbo].[Product] p \r\n    WHERE oi.[ProductID] = p.[ProductID]\r\n)  \r\nGROUP BY oi.[OrderID]\r\n```\r\n\r\n###Nested SubQuery###\r\n\r\nTiraggo supports nesting of SubQueries. Each database vendor has their own limits on just how deep the nesting can go. Tiraggo supports two different syntax approaches to nested SubQueries.\r\n\r\nTraditional SQL-style syntax is most useful if you already have a query designed using standard SQL, and are just converting it to a DynamicQuery.\r\n\r\n```csharp\r\nOrderQuery oq = new OrderQuery(\"o\");\r\nCustomerQuery cq = new CustomerQuery(\"c\");\r\nEmployeeQuery eq = new EmployeeQuery(\"e\");\r\n\r\n// OrderID and CustID for customers who ordered on the same date\r\n// a customer was added, and have a manager whose \r\n// last name starts with 'S'.\r\noq.Select(\r\n    oq.OrderID,\r\n    oq.CustID\r\n);\r\noq.Where(oq.OrderDate\r\n    .In(\r\n        cq.Select(cq.DateAdded)\r\n        .Where(cq.Manager.In(\r\n            eq.Select(eq.EmployeeID)\r\n            .Where(eq.LastName.Like(\"S%\"))\r\n            )\r\n        )\r\n    )\r\n);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Order> orders = oq.ToList<Order>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT o.[OrderID],o.[CustID]  \r\nFROM [dbo].[Order] o \r\nWHERE o.[OrderDate] IN \r\n(\r\n\tSELECT c.[DateAdded]  \r\n\tFROM [dbo].[Customer] c \r\n\tWHERE c.[Manager] IN \r\n\t(\r\n\t\tSELECT e.[EmployeeID]  \r\n\t\tFROM [dbo].[Employee] e \r\n\t\tWHERE e.[LastName] LIKE @LastName1\r\n\t) \r\n)\r\n```\r\n\r\nNesting by query instance name can be easier to understand and construct, if you are starting from scratch, and have no pre-existing SQL to go by. The trick is to start with the inner-most SubQuery and work your way out. The query below produces the same results as the traditional SQL-style query above. The instance names are color coded to emphasize how they are nested.\r\n\r\n```csharp\r\n// Employees whose LastName begins with 'S'.\r\nEmployeeQuery eq = new EmployeeQuery(\"e\");\r\neq.Select(eq.EmployeeID);\r\neq.Where(eq.LastName.Like(\"S%\"));\r\n\r\n// DateAdded for Customers whose Managers are in the\r\n// EmployeeQuery above.\r\nCustomerQuery cq = new CustomerQuery(\"c\");\r\ncq.Select(cq.DateAdded);\r\ncq.Where(cq.Manager.In(eq));\r\n\r\n// OrderID and CustID where the OrderDate is in the\r\n// CustomerQuery above.\r\nOrderQuery oq = new OrderQuery(\"o\");\r\noq.Select(oq.OrderID, oq.CustID);\r\noq.Where(oq.OrderDate.In(cq));\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Order> orders = oq.ToList<Order>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT o.[OrderID],o.[CustID]  \r\nFROM [dbo].[Order] o \r\nWHERE o.[OrderDate] IN \r\n(\r\n    SELECT c.[DateAdded]  \r\n    FROM [dbo].[Customer] c \r\n    WHERE c.[Manager] IN \r\n\t(\r\n        SELECT e.[EmployeeID]  \r\n        FROM [dbo].[Employee] e \r\n        WHERE e.[LastName] LIKE @LastName1\r\n\t)\r\n)\r\n```\r\n\r\n###Any, All, and Some###\r\n\r\nANY, ALL, and SOME are SubQuery qualifiers. They precede the SubQuery they apply to. For most databases, ANY and SOME are synonymous. Usually, if you use an operator (>, >=, =, <, <=) in a Where clause against a SubQuery, then the SubQuery must return a single value. By applying a qualifier to the SubQuery, you can use operators against SubQueries that return multiple results.\r\n\r\nNotice, below, that the ALL qualifier is set to true for the SubQuery with \"cq.tg.All = true;\".\r\n\r\n```csharp\r\n// DateAdded for Customers whose Manager  = 3\r\nCustomerQuery cq = new CustomerQuery(\"c\");\r\ncq.tg.All = true;\r\ncq.Select(cq.DateAdded);\r\ncq.Where(cq.Manager == 3);\r\n\r\n// OrderID and CustID where the OrderDate is \r\n// less than all of the dates in the CustomerQuery above.\r\nOrderQuery oq = new OrderQuery(\"o\");\r\noq.Select(oq.OrderID, oq.CustID);\r\noq.Where(oq.OrderDate < cq);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Order> orders = oq.ToList<Order>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT o.[OrderID],o.[CustID]  \r\nFROM [dbo].[Order] o \r\nWHERE o.[OrderDate] < ALL \r\n(\r\n    SELECT c.[DateAdded]  \r\n    FROM [ForeignKeyTest].[dbo].[Customer] c \r\n    WHERE c.[Manager] = @Manager1\r\n)\r\n```\r\n\r\nBelow, is a nested SubQuery. The ANY qualifier is set to true for the middle SubQuery with \"cq.tg.Any = true;\".\r\n\r\n```csharp\r\n// Employees whose LastName begins with 'S'.\r\nEmployeeQuery eq = new EmployeeQuery(\"e\");\r\neq.Select(eq.EmployeeID);\r\neq.Where(eq.LastName.Like(\"S%\"));\r\n\r\n// DateAdded for Customers whose Managers are in the\r\n// EmployeeQuery above.\r\nCustomerQuery cq = new CustomerQuery(\"c\");\r\ncq.tg.Any = true;\r\ncq.Select(cq.DateAdded);\r\ncq.Where(cq.Manager.In(eq));\r\n\r\n// OrderID and CustID where the OrderDate is \r\n// less than any one of the dates in the CustomerQuery above.\r\nOrderQuery oq = new OrderQuery(\"o\");\r\noq.Select(oq.OrderID, oq.CustID);\r\noq.Where(oq.OrderDate < cq);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Order> orders = oq.ToList<Order>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT o.[OrderID],o.[CustID]  \r\nFROM [dbo].[Order] o \r\nWHERE o.[OrderDate] < ANY \r\n(\r\n    SELECT c.[DateAdded]  \r\n    FROM [dbo].[Customer] c \r\n    WHERE c.[Manager] IN \r\n\t(\r\n        SELECT e.[EmployeeID]  \r\n        FROM [dbo].[Employee] e \r\n        WHERE e.[LastName] LIKE @LastName1\r\n\t)\r\n)\r\n```\r\n\r\n###Case().When().Then().End() Syntax###\r\n\r\n```csharp\r\nEmployeesQuery q = new EmployeesQuery();\r\nq.Select(q.EmployeeID, q.FirstName);\r\nq.Where(q.EmployeeID == 2);\r\n \r\nOrderDetailsQuery oq = new OrderDetailsQuery();\r\noq.Select\r\n(\r\n  oq.UnitPrice.Case()\r\n    .When(\"yay\").Then(\"wow\")\r\n    .When(oq.Exists(q)).Then(\"Exists!!\")\r\n    .When(oq.Quantity >= 50).Then(oq.UnitPrice)\r\n    .When(oq.Quantity  / 50 / 50 == 0).Then(oq.UnitPrice)\r\n    .When(oq.Quantity >= 50 && oq.Quantity < 250).Then(1)\r\n    .When(oq.Quantity >= 250 && oq.Quantity < 1000).Then(oq.UnitPrice * .80)\r\n    .Else(\"Huh?\")\r\n    .End()\r\n);\r\noq.Where(oq.Quantity.Sum() >= 50 && oq.Quantity.Avg() < 250);\r\noq.OrderBy(oq.OrderID.Descending, oq.Quantity.Descending);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<OrderDetails> details = oq.ToList<OrderDetails>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT \r\n  CASE UnitPrice  \r\n    WHEN 'yay' THEN 'wow' \r\n    WHEN  EXISTS \r\n    (\r\n        SELECT [EmployeeID],[FirstName]  \r\n        FROM [Employees] \r\n        WHERE [EmployeeID] = @EmployeeID1\r\n    ) THEN 'Exists!!' \r\n    WHEN [Quantity] >= @Quantity2 THEN [UnitPrice] \r\n    WHEN (([Quantity] / 50) / 50) = @Expr3 THEN [UnitPrice] \r\n    WHEN ([Quantity] >= @Quantity4 AND [Quantity] < @Quantity5) THEN 1 \r\n    WHEN ([Quantity] >= @Quantity6 AND [Quantity] < @Quantity7) THEN \r\n         ([UnitPrice] * 0.8) \r\n    ELSE 'Huh?'  \r\n    END    \r\nFROM [Order Details] \r\nWHERE (SUM([Quantity]) >= @Quantity8 AND AVG([Quantity]) < @Quantity9) \r\nORDER BY [OrderID] DESC,[Quantity] DESC\r\n```\r\n\r\nAnother Case/When Query\r\n\r\n```csharp\r\nEmployeeQuery q = new EmployeeQuery();\r\n\r\nq.Select\r\n(\r\n    q.LastName\r\n        .Case()\r\n            .When(q.LastName.Like(\"%a%\")).Then(\"Last Name Contains an A\")\r\n            .Else(\"Last Name Doesnt Contain an A\")\r\n        .End().As(\"SpecialLastName\")\r\n);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Employee> employees = q.ToList<Employee>(context);\r\n}\r\n```\r\n\r\n###Having Clause###\r\n\r\n```csharp\r\nEmployeeQuery q = new EmployeeQuery();\r\nq.Select(q.EmployeeID, q.Age.Sum().As(\"TotalAge\"));\r\nq.Where(q.EmployeeID.IsNotNull());\r\nq.GroupBy(q.EmployeeID);\r\nq.Having(q.Age.Sum() > 5);\r\nq.OrderBy(q.EmployeeID.Descending);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Employee> employees = q.ToList<Employee>(context);\r\n}\r\n```\r\n\r\nResults:\r\n```sql\r\nSELECT [EmployeeID] AS 'EmployeeID',SUM([Age]) AS 'TotalAge' \r\nFROM [dbo].[Employee] \r\nWHERE[EmployeeID] IS NOT NULL \r\nGROUP BY [EmployeeID] \r\nHAVING SUM([Age]) > @Age2 \r\nORDER BY [EmployeeID] DESC\r\n```\r\n\r\n###Union, Intersect, and Except###\r\n\r\nThese might be kind of silly but they demonstrate syntax.\r\n\r\nUnion\r\n```csharp\r\nEmployeeQuery eq1 = new EmployeeQuery(\"eq1\");\r\nEmployeeQuery eq2 = new EmployeeQuery(\"eq2\");\r\n\r\n// This leaves out the record with Age 30\r\neq1.Where(eq1.Age < 30);\r\neq1.Union(eq2);\r\neq2.Where(eq2.Age > 30);\r\n```\r\n\r\nIntersect\r\n```csharp\r\nEmployeeQuery eq1 = new EmployeeQuery(\"eq1\");\r\nEmployeeQuery eq2 = new EmployeeQuery(\"eq2\");\r\n\r\n// This leaves out the record with Age 30\r\neq1.Where(eq1.FirstName.Like(\"%n%\"));\r\neq1.Intersect(eq2);\r\neq2.Where(eq2.FirstName.Like(\"%a%\"));\r\n```\r\n\r\nExcept\r\n```csharp\r\nEmployeeQuery eq1 = new EmployeeQuery(\"eq1\");\r\nEmployeeQuery eq2 = new EmployeeQuery(\"eq2\");\r\n\r\n// This leaves out the record with Age 30\r\neq1.Where(eq1.FirstName.Like(\"%J%\"));\r\neq1.Except(eq2);\r\neq2.Where(eq2.FirstName == \"Jim\");\r\n```\r\n\r\n###Raw SQL Injection Everywhere###\r\n\r\nThere may be times when you need to access some SQL feature that is not supported by the DynamicQuery API. But, now having used and fallen in love with DynamicQuery, the last thing you want to do is stop and go write a stored procedure or create a view. We have always supported the raw injection feature in our Select statement, but it will soon be available almost everywhere. The way it works is you pass in raw SQL in the form of a string surrounded by < > angle brackets. That indicates that you want the raw SQL passed directly to the database engine “as is”.\r\n\r\nHere is an example query. You would never write a query like this in reality. Tiraggo supports this simple query without having to use < > angle brackets. This is just to show all of the places that can accept the raw SQL injection technique:\r\n\r\n```csharp\r\nEmployeesQuery q = new EmployeesQuery();\r\nq.Select(\"<FirstName>\", q.HireDate);\r\nq.Where(\"<EmployeeID = 1>\");\r\nq.GroupBy(\"<FirstName>\", q.HireDate);\r\nq.OrderBy(\"<FirstName ASC>\"); \r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Employee> employees = q.ToList<Employee>(context);\r\n}\r\n```\r\n\r\nThe SQL Generated is as follows (and works)\r\n\r\nResults:\r\n```sql\r\nSELECT FirstName,[HireDate] AS 'HireDate'  \r\nFROM [Employees] WHERE (EmployeeID = 1) \r\nGROUP BY FirstName,[HireDate] \r\nORDER BY FirstName ASC\r\n```\r\n\r\nOf course, you could easily write the above query without injection, but you get the idea. The escape hatch will be available to you almost everywhere ….\r\n\r\n```csharp\r\nEmployeesQuery q = new EmployeesQuery();\r\nq.Select(q.FirstName);\r\nq.Where(q.EmployeeID == 1);\r\nq.OrderBy(q.FirstName.Ascending);\r\nq.GroupBy(q.FirstName, q.HireDate);\r\n```\r\n\r\nUsing the raw SQL injection techniques above will allow you to invoke SQL functions that we don’t support, including database vender specific SQL, and so on. Hopefully, you will almost never have to resort to writing a custom load method to invoke a stored procedure or an entirely hand written SQL statement. Of course, you can use our native API everywhere and just inject the raw SQL on the GroupBy for instance. You can mix and match to get the desired SQL.\r\n\r\n##Some Final Thoughts##\r\n\r\nThe examples given above were designed to demonstrate (and test) usage in a variety of settings. They are not necessarily the simplest, or most efficient, way to achieve the desired result set. Think of them as an API usage guide, not as design guidelines. Most SubQueries can be re-written as Joins, and most Joins can be re-written as SubQueries. If, while coding, you are having trouble conceptualizing one approach, then try the other.\r\n\r\nTechnically, a JOIN's ON clause can take almost any where_condition, and Tiraggo supports many of these, including SubQueries. But, I agree with most authorities on the subject, that the ON clause should be reserved for the conditions that relate the two tables. All other conditional statements should be placed in a WHERE clause. Typically, the ON clause only contains a column from each table and a comparison operator.\r\n\r\nFor example, take the Join(query).On(SubQuery) example above. The much simpler query below returns the same result set. Its Where() clause not only simplifies the On() clause, but eliminates the SubQuery completely.\r\n\r\n```csharp\r\n// Query for the Join\r\nOrderItemQuery oiq = new OrderItemQuery(\"oi\");\r\n\r\n// Orders with discounted items\r\nOrderQuery oq = new OrderQuery(\"o\");\r\noq.Select(oq.OrderID, oiq.Discount);\r\noq.InnerJoin(oiq).On(oq.OrderID == oiq.OrderID);\r\noq.Where(oiq.Discount > 0);\r\n\r\nusing(MyEntities context = new MyEntities())\r\n{\r\n\tIList<Order> orders = oq.ToList<Order>(context);\r\n}\r\n```\r\n\r\n##The rest of the Tiraggo Suite##\r\n\r\n[Tiraggo](http://brewdawg.github.io/Tiraggo/) - A C# Cross Platform ORM Architecture derived from EntitySpaces (Full Xamarin Mono Touch Support).\r\n\r\n[Tiraggo.js](http://brewdawg.github.io/Tiraggo.js/) - A JavaScript ORM to Compliment the Main Tiraggo Architecture","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}