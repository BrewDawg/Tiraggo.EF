<#@ template hostSpecific="true" debug="false" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<# var manager = Manager.Create(Host, GenerationEnvironment); #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:<#=Environment.Version.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#
	var xsdClassGen = new XsdClassGen(manager.GetItemNamespace(Host.TemplateFile));
	IServiceProvider hostServiceProvider = (IServiceProvider)Host;
	EnvDTE.DTE dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
	EnvDTE.ProjectItem templateProjectItem = dte.Solution.FindProjectItem(Host.TemplateFile);
	EnvDTE.Project project = templateProjectItem.ContainingProject;
	foreach (EnvDTE.ProjectItem projectItem in GetAllItems(project.ProjectItems.Cast<EnvDTE.ProjectItem>()))
	{
		string path = projectItem.get_FileNames(0);
		string directory = Path.GetDirectoryName(path);
		if (path.EndsWith(".xsd"))
		{
			xsdClassGen.AddSchema(path);
		}
		if (path.EndsWith("XsdClassGen.mapping"))
		{
			xsdClassGen.LoadMappings(path);
		}
	}
	IDictionary<string, List<string>> typeNameMappings;
	using(StringWriter writer = new StringWriter(GenerationEnvironment))
	{
		typeNameMappings = xsdClassGen.Generate(writer);
	}
	foreach(var codeNamespace in typeNameMappings.Keys)
	{
		foreach(var typeName in typeNameMappings[codeNamespace])
		{
			manager.StartNewFile(typeName + ".Serialization.cs");
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by XsdClassGen.tt.
//     Runtime Version:<#=Environment.Version.ToString()#>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace <#= codeNamespace  #>
{
	public partial class <#= typeName #>
	{
		public static <#= typeName #> DeserializeFrom(Stream stream)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(<#= typeName #>));
			return (<#= typeName #>)serializer.Deserialize(stream);
		}

		public static <#= typeName #> DeserializeFrom(TextReader reader)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(<#= typeName #>));
			return (<#= typeName #>)serializer.Deserialize(reader);
		}

		public static <#= typeName #> DeserializeFrom(XmlReader reader)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(<#= typeName #>));
			return (<#= typeName #>)serializer.Deserialize(reader);
		}

		public void SerializeTo(Stream stream)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(<#= typeName #>));
			serializer.Serialize(stream, this);
		}

		public void SerializeTo(TextWriter writer)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(<#= typeName #>));
			serializer.Serialize(writer, this);
		}

		public void SerializeTo(XmlWriter writer)
		{
			XmlSerializer serializer = new XmlSerializer(typeof(<#= typeName #>));
			serializer.Serialize(writer, this);
		}
	}
}
<#
			manager.EndBlock();
		}
	}
	manager.Process(true);
#>
<#+
	private IEnumerable<EnvDTE.ProjectItem> GetAllItems(IEnumerable<EnvDTE.ProjectItem> projectItems)
	{
		return projectItems.Concat(projectItems.SelectMany(i => GetAllItems(i.ProjectItems.Cast<EnvDTE.ProjectItem>())));
	}

    public class XsdClassGen
    {
        private class SchemaMapping
        {
            public SchemaMapping()
            {
                TypeMappings = new Dictionary<string, string>();
            }

            public string SchemaNamespace { get; set; }
            public string CodeNamespace { get; set; }
            public IDictionary<string, string> TypeMappings { get; private set; }
        }

        private readonly CodeDomProvider _codeProvider;
        private readonly string _defaultCodeNamespace;
        private readonly XmlSchemas _schemas = new XmlSchemas();
        private readonly Dictionary<string, SchemaMapping> _schemaMappings = new Dictionary<string,SchemaMapping>();

        public XsdClassGen()
            : this(new CSharpCodeProvider(), "")
        {
        }

        public XsdClassGen(string defaultCodeNamespace)
            : this(new CSharpCodeProvider(), defaultCodeNamespace)
        {
        }

        public XsdClassGen(CodeDomProvider codeProvider, string defaultCodeNamespace)
        {
            _codeProvider = codeProvider;
            _defaultCodeNamespace = defaultCodeNamespace;
        }

        public void AddSchema(string path)
        {
            using (var stream = File.OpenRead(path))
            {
                var schema = XmlSchema.Read(stream, null);
                _schemas.Add(schema);
                ApplySchemaNamespaceMapping(schema.TargetNamespace, _defaultCodeNamespace);
            }
        }

        public void LoadMappings(string path)
        {
            using (var reader = File.OpenText(path))
            {
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    line = line.Trim();
                    if ((line.Length == 0) || (line.StartsWith("#")))
                    {
                        continue;
                    }
                    var mapping = line.Split(',');
                    if (mapping.Length == 2)
                    {
                        ApplySchemaNamespaceMapping(mapping[0], mapping[1]);
                    }
                    if (mapping.Length == 3)
                    {
                        ApplyTypeNameMapping(mapping[0], mapping[1], mapping[2]);
                    }
                }
            }
        }

        public void ApplySchemaNamespaceMapping(string schemaNamespace, string codeNamespace)
        {
            if (_schemaMappings.Keys.Contains(schemaNamespace))
            {
                _schemaMappings[schemaNamespace].CodeNamespace = codeNamespace;
            }
            else
            {
                _schemaMappings.Add(schemaNamespace,
                                    new SchemaMapping { SchemaNamespace = schemaNamespace, CodeNamespace = codeNamespace });
            }
        }

        public void ApplyTypeNameMapping(string schemaNamespace, string elementName, string typeName)
        {
            SchemaMapping mapping;
            if (_schemaMappings.Keys.Contains(schemaNamespace))
            {
                mapping = _schemaMappings[schemaNamespace];
            }
            else
            {
                ApplySchemaNamespaceMapping(schemaNamespace, _defaultCodeNamespace);
                mapping = _schemaMappings[schemaNamespace];
            }
            if (mapping.TypeMappings.Keys.Contains(elementName))
            {
                mapping.TypeMappings[elementName] = typeName;
            }
            else
            {
                mapping.TypeMappings.Add(elementName, typeName);
            }
        }

        public IDictionary<string, List<string>> Generate(TextWriter writer)
        {
            var rootElementTypes = new Dictionary<string, List<string>>();
            var codeGeneratorOptions = new CodeGeneratorOptions();
            var schemaImporter = new XmlSchemaImporter(_schemas);
            _schemas.Compile(null, true);
            foreach (var mapping in _schemaMappings.Values)
            {
                var codeNamespace = GenerateCodeForMapping(mapping, schemaImporter);
                _codeProvider.GenerateCodeFromNamespace(codeNamespace, writer, codeGeneratorOptions);
                var rootTypes = GetSchemaRootElementTypeNames(codeNamespace).ToList();
                if (rootElementTypes.ContainsKey(mapping.CodeNamespace))
                {
                    var types = rootElementTypes[mapping.CodeNamespace];
                    types.AddRange(rootTypes);
                }
                else
                {
                    rootElementTypes.Add(mapping.CodeNamespace, rootTypes);
                }
            }
            return rootElementTypes;
        }

        private CodeNamespace GenerateCodeForMapping(SchemaMapping mapping, XmlSchemaImporter schemaImporter)
        {
            var codeNamespace = new CodeNamespace(mapping.CodeNamespace);
            var codeExporter = new XmlCodeExporter(codeNamespace);
            var maps = new List<XmlTypeMapping>();
            maps.AddRange(_schemas
                .Where(schema => schema.TargetNamespace == mapping.SchemaNamespace)
                .SelectMany(schema => schema.SchemaTypes.Values.Cast<XmlSchemaType>()
                    .Select(schemaType => schemaImporter.ImportSchemaType(schemaType.QualifiedName))));
            maps.AddRange(_schemas
                .Where(schema => schema.TargetNamespace == mapping.SchemaNamespace)
                .SelectMany(schema => schema.Elements.Values.Cast<XmlSchemaElement>()
                    .Select(schemaElement => schemaImporter.ImportTypeMapping(schemaElement.QualifiedName))));
            foreach (var map in maps)
            {
                codeExporter.ExportTypeMapping(map);
            }
            CodeGenerator.ValidateIdentifiers(codeNamespace);
            ApplyTypeMappings(codeNamespace, mapping);
            return codeNamespace;
        }

        private static void ApplyTypeMappings(CodeNamespace codeNamespace, SchemaMapping mapping)
        {
            foreach (var elementName in mapping.TypeMappings.Keys)
            {
                var typeName = mapping.TypeMappings[elementName];
                var codeType = FindTypeForSchemaRoot(codeNamespace, mapping.SchemaNamespace, elementName);
                var oldName = codeType.Name;
                codeType.Name = typeName;
                UpdateAttributeArguments<XmlRootAttribute>(codeType, "", oldName);
                UpdateAttributeArguments<XmlTypeAttribute>(codeType, "TypeName", oldName);
            }
        }

        private IEnumerable<string> GetSchemaRootElementTypeNames(CodeNamespace codeNamespace)
        {
            return _schemas
                .SelectMany(xsd => xsd.Elements.Values.Cast<XmlSchemaElement>())
                .Where(e => e.ElementSchemaType is XmlSchemaComplexType)
                .Select(e => FindTypeForSchemaRoot(codeNamespace, e.QualifiedName.Namespace, e.QualifiedName.Name))
                .Where(t => t != null)
                .Select(t => t.Name);
        }

        private static CodeTypeDeclaration FindTypeForSchemaRoot(CodeNamespace codeNamespace, string schemaNs, string elementName)
        {
            return codeNamespace.Types.Cast<CodeTypeDeclaration>().FirstOrDefault(t => HasXmlRootAttribute(t, schemaNs, elementName));
        }

        private static bool HasXmlRootAttribute(CodeTypeMember codeType, string schemaNs, string elementName)
        {
            var rootAttrib = GetCodeAttributeDeclaration<XmlRootAttribute>(codeType);
            if (rootAttrib == null)
            {
                return false;
            }
            var nsArg = GetAttributeArgument(rootAttrib, "Namespace");
            if (nsArg == null)
            {
                return false;
            }
            if ((string)GetAttributeArgumentValue(nsArg) != schemaNs)
            {
                return false;
            }
            var nameArg = GetAttributeArgument(rootAttrib, "");
            var name = codeType.Name;
            if (nameArg != null)
            {
                name = (string)GetAttributeArgumentValue(nameArg);
            }
            return name == elementName;
        }

        private static void UpdateAttributeArguments<T>(CodeTypeMember codeType, string findArg, string oldValue) where T : Attribute
        {
            var attrib = GetCodeAttributeDeclaration<T>(codeType);
            var arg = GetAttributeArgument(attrib, findArg);
            if (arg != null)
            {
                return;
            }
            arg = new CodeAttributeArgument(findArg, new CodePrimitiveExpression(oldValue));
            attrib.Arguments.Insert(0, arg);
        }

        private static CodeAttributeDeclaration GetCodeAttributeDeclaration<T>(CodeTypeMember type)
        {
            return type.CustomAttributes.Cast<CodeAttributeDeclaration>().FirstOrDefault(a => a.Name == typeof(T).FullName);
        }

        private static CodeAttributeArgument GetAttributeArgument(CodeAttributeDeclaration attribute, string argument)
        {
            return attribute.Arguments.Cast<CodeAttributeArgument>().FirstOrDefault(a => a.Name == argument);
        }

        private static object GetAttributeArgumentValue(CodeAttributeArgument arg)
        {
            return arg == null ? null : ((CodePrimitiveExpression)arg.Value).Value;
        }
    }

	// Manager class records the various blocks so it can split them up
	// From http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
	class Manager {
		private class Block {
			public String Name;
			public int Start, Length;
		}

		private Block currentBlock;
		private List<Block> files = new List<Block>();
		private Block footer = new Block();
		private Block header = new Block();
		private ITextTemplatingEngineHost host;
		private StringBuilder template;
		protected List<String> generatedFileNames = new List<String>();

		public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
			return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
		}

		public void StartNewFile(String name) {
			if (name == null)
				throw new ArgumentNullException("name");
			CurrentBlock = new Block { Name = name };
		}

		public void StartFooter() {
			CurrentBlock = footer;
		}

		public void StartHeader() {
			CurrentBlock = header;
		}

		public void EndBlock() {
			if (CurrentBlock == null)
				return;
			CurrentBlock.Length = template.Length - CurrentBlock.Start;
			if (CurrentBlock != header && CurrentBlock != footer)
				files.Add(CurrentBlock);
			currentBlock = null;
		}

		public virtual void Process(bool split) {
			if (split) {
				EndBlock();
				String headerText = template.ToString(header.Start, header.Length);
				String footerText = template.ToString(footer.Start, footer.Length);
				String outputPath = Path.GetDirectoryName(host.TemplateFile);
				files.Reverse();
				foreach(Block block in files) {
					String fileName = Path.Combine(outputPath, block.Name);
					String content = headerText + template.ToString(block.Start, block.Length) + footerText;
					generatedFileNames.Add(fileName);
					CreateFile(fileName, content);
					template.Remove(block.Start, block.Length);
				}
			}
		}

		protected virtual void CreateFile(String fileName, String content) {
			if (IsFileContentDifferent(fileName, content))
				File.WriteAllText(fileName, content);
		}

		public virtual String GetCustomToolNamespace(String fileName) {
			return null;
		}

		public virtual String GetItemNamespace(String filename) {
			String customNamespace = GetCustomToolNamespace(filename);
		
			if(String.IsNullOrEmpty(customNamespace)) {
				return DefaultProjectNamespace;
			}

			return customNamespace;
		}

		public virtual String DefaultProjectNamespace {
			get { return null; }
		}

		protected bool IsFileContentDifferent(String fileName, String newContent) {
			return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
		}

		private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
			this.host = host;
			this.template = template;
		}

		private Block CurrentBlock {
			get { return currentBlock; }
			set {
				if (CurrentBlock != null)
					EndBlock();
				if (value != null)
					value.Start = template.Length;
				currentBlock = value;
			}
		}

		private class VSManager: Manager {
			private EnvDTE.ProjectItem templateProjectItem;
			private EnvDTE.DTE dte;
			private Action<String> checkOutAction;
			private Action<IEnumerable<String>> projectSyncAction;

			public override String DefaultProjectNamespace {
				get {
					return templateProjectItem.ContainingProject.Properties.Item("RootNamespace").Value.ToString();
				}
			}

			public override String GetItemNamespace(String filename) {
				String customNamespace = GetCustomToolNamespace(filename);
				if(!String.IsNullOrEmpty(customNamespace)) {
					return customNamespace;
				}

				List<string> namespaces = new List<string>();
				EnvDTE.ProjectItem parent = templateProjectItem.Collection.Parent as EnvDTE.ProjectItem;
				while (parent != null) {
					if (parent.Kind != EnvDTE.Constants.vsProjectItemKindPhysicalFile)
						namespaces.Insert(0, parent.Name.Replace(" ", string.Empty));

					parent = parent.Collection.Parent as EnvDTE.ProjectItem;
				}

				namespaces.Insert(0, DefaultProjectNamespace);
				return string.Join(".", namespaces.ToArray());
			}

			public override String GetCustomToolNamespace(string fileName) {
				return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
			}

			public override void Process(bool split) {
				if (templateProjectItem.ProjectItems == null)
					return;
				base.Process(split);
				projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
			}

			protected override void CreateFile(String fileName, String content) {
				if (IsFileContentDifferent(fileName, content)) {
					CheckoutFileIfRequired(fileName);
					File.WriteAllText(fileName, content);
				}
			}

			internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
				: base(host, template) {
				var hostServiceProvider = (IServiceProvider) host;
				if (hostServiceProvider == null)
					throw new ArgumentNullException("Could not obtain IServiceProvider");
				dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
				if (dte == null)
					throw new ArgumentNullException("Could not obtain DTE from host");
				templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
				checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
				projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
			}

			private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
				var keepFileNameSet = new HashSet<String>(keepFileNames);
				var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
				var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
				foreach(EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
					projectFiles.Add(projectItem.get_FileNames(0), projectItem);

				// Remove unused items from the project
				foreach(var pair in projectFiles)
					if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
						pair.Value.Delete();

				// Add missing files to the project
				foreach(String fileName in keepFileNameSet)
					if (!projectFiles.ContainsKey(fileName))
						templateProjectItem.ProjectItems.AddFromFile(fileName);
			}

			private void CheckoutFileIfRequired(String fileName) {
				var sc = dte.SourceControl;
				if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
					checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
			}
		}
	}
#>